#!/usr/bin/env python3

import os
import sys
import glob
import argparse
import subprocess
import configparser

from libraries.dependencies import dependencies

config = {}

# Find the imp installation directory
imp_root = sys.modules[__name__].__file__
imp_root = os.path.realpath(imp_root)
imp_root = os.path.dirname(imp_root)

os.environ["PATH"] += ":" + imp_root

def read_boards():
	"""Parse boards.txt and return a dictionary."""
	boards = {}
	arduino_root = config['arduino_root']
	filepath = os.path.join(arduino_root, "hardware/arduino/boards.txt")
	f = open(filepath, "r")
	for line in f:
		if line[0] in "\n#":
			continue

		(key, value) = line.strip().split("=")
		key = key.split(".")
		board = key[0]
		property = ".".join(key[1:])
		if board not in boards:
			boards[board] = {}
		boards[board][property] = value

	f.close()
	return boards


def read_config():
	"""Read imp config from ~/.imprc and .imp

	Values in .imp override those in ~/.imprc
	"""
	parser = configparser.ConfigParser()

	# Load defaults
	defaults = {"imp": {	"arduino_root": "/usr/share/arduino",
				"arduino_ver": "105",
				"compile_root": "~/.imp/"
	}}
	parser.read_dict(defaults)

	# Read ~/.imprc
	imprc = os.path.expanduser("~/.imprc")
	if os.path.exists(imprc):
		parser.read(imprc)

	# Read .imp
	dotimp = os.path.abspath(".imp")
	if os.path.exists(dotimp):
		parser.read(dotimp)

	config = dict(parser["imp"])

	# Expand paths
	config["arduino_root"] = os.path.expanduser(config["arduino_root"])
	config["compile_root"] = os.path.expanduser(config["compile_root"])

	return config


# ------------ #
#   Commands   #
# ------------ #

def init(args):
	"""Create a new project from the makefile template."""
	proj_root = os.path.abspath(args.dir)
	name = input("Project name: ")
	board = input("Board: ")
	proj_dir = os.path.join(proj_root, name)


def list_boards(args):
	"""List all available boards from boards.txt"""
	boards = read_boards()
	_list_boards(boards)


def _list_boards(boards):
	"""Pretty print a list of boards in alphabetical order."""
	board_names = sorted(boards.keys(), key=lambda x: x.lower())
	for board in board_names:
		spacer = "\t\t" if len(board) < 8 else "\t"
		print("%s%s'%s'" % (board, spacer, boards[board]["name"]))


def get_property(args):
	"""Print the board property requested on the command-line.

	A property is just a bit of information from the Arduino library's
	collection of hardware specific information - "boards.txt".

	Throughout Imp, the names from "boards.txt" are split into a
	board name and a "property".

	Example:
	If the board is "atmega328" and property is "build.f_cpu"
	the value of "atmega328.build.f_cpu" will be fetched.
	"""
	boards = read_boards()
	key = args.property.split(".")
	board = key[0]
	subprop = ".".join(key[1:])
	print(boards[board][subprop])


def get_cflags(args):
	"""Print the C compiler flags for the given board."""
	boards = read_boards()
	cflags = _get_cflags(args.board, boards)
	print(cflags)


def _get_cflags(board, boards):
	"""Get the C compiler flags for the given board."""
	board_info = boards[board]
	flags = "-mmcu=%(build.mcu)s -DF_CPU=%(build.f_cpu)s" % board_info
	flags += " -DARDUINO=%s" % config["arduino_ver"]
	return flags


def get_src(args):
	"""Print a list of source directories for the requested libraries.

	The list items can optionally be separated by -I to form a string
	suitable for appending to GCC. Dependencies not included.
	"""
	# If the board argument is provided, read boards.txt to get variant
	if args.board:
		boards = read_boards()
		variant = boards[args.board]["build.variant"]
	else:
		variant = "standard"

	# Get the list of libraries
	libraries = args.libraries

	# Automatically include the core library
	if "core" not in libraries:
		libraries.append("core")

	# Fetch the source code directories
	src_dirs = _get_src(libraries, variant)

	if args.dash_i:
		output = "-I " + " -I ".join(src_dirs)
	else:
		output = " ".join(src_dirs)

	print(output)


def _get_src(libraries, variant):
	"""Return a list of directories containing relevant source code.

	By relevant source code, we mean source code for those libraries listed
	in the `libraries' argument (a list). The core Arduino library is
	not included unless "core" is amongst the list of libraries.

	If the core library is requested, "variant" is the type of
	Arduino board to compile for. Most boards are just "standard".
	"""
	src_dirs = []
	root = config["arduino_root"]

	# Sub-function to get the core library
	def get_core():
		core = os.path.join(root, "hardware/arduino/cores/arduino")
		libc = os.path.join(core, "avr-libc")
		var_dir = os.path.join(root, "hardware/arduino/variants/%s" % variant)
		return [core, libc, var_dir]

	# Add requested libraries
	for lib in libraries:
		# Treat the core library carefully
		if lib == "core":
			src_dirs.extend(get_core())
			continue

		# Look in libraries/name otherwise
		lib_main = os.path.join(root, "libraries/%s" % lib)
		src_dirs.append(lib_main)

		lib_util = os.path.join(lib_main, "utility")
		if os.path.exists(lib_util):
			src_dirs.append(lib_util)

	return src_dirs


def get_obj(args):
	"""Print the names of all the .o files for a given library."""
	library = args.library

	# Convert the library name into a list of directories
	if library == "core":
		# XXX: This takes advantage of the fact that the variant
		# folders only include headers. Might need to be updated.
		library_dirs = _get_src(["core"], "standard")
	else:
		library_dirs = _get_src([args.library], "n/a")

	objects = _get_obj(library_dirs)
	print(" ".join(objects))


def _get_obj(library_dirs):
	"""Get the names of all the .o files in the given directories."""
	# Filter functions, to turn source filepaths into object filenames
	c_filter = lambda x: x.split("/")[-1].replace(".c", ".o")
	cpp_filter = lambda x: x.split("/")[-1].replace(".cpp", ".o")

	# Find objects for each directory in the input
	objects = []
	for directory in library_dirs:
		c_files = glob.glob("%s/*.c" % directory)
		objects.extend([c_filter(x) for x in c_files])
		cpp_files = glob.glob("%s/*.cpp" % directory)
		objects.extend([cpp_filter(x) for x in cpp_files])

	return objects


def get_lib(args):
	"""Print a list of folders containing the requested libraries, compiled.

	The libraries are either compiled from scratch or fetched from the
	cache that accumulates in config['compile_root'].
	"""
	boards = read_boards()
	board = args.board
	libraries = args.libraries

	# Add the core library if it isn't present
	if "core" not in libraries:
		libraries.append("core")

	# Make
	library_list = _get_lib(libraries, board, boards)

	print(" ".join(library_list))


def _get_lib(libraries, board, boards):
	"""Make each library in compile_root/board/library.

	Return a list of directories containing compiled versions.
	Dependecies are compiled and have their folders included.
	"""
	# Resolve dependencies (using sets & BFS style search)
	active_pool = {lib for lib in libraries}
	libraries = set()
	while len(active_pool) > 0:
		new_pool = set()
		for lib in active_pool:
			if lib in dependencies:
				new_libs = dependencies[lib].difference(libraries)
				new_libs = new_libs.difference(active_pool)
				new_pool.update(new_libs)
			libraries.add(lib)
		active_pool = new_pool

	# Set up environment variables for each make instance
	env = {lib: {"LIBRARY": lib} for lib in libraries}

	# Set up a dictionary of make processes
	makes = {lib: None for lib in libraries}

	# Set up the list of directories to return
	library_list = []

	# Set up common arguments
	cflags = _get_cflags(board, boards)
	variant = boards[board]["build.variant"]
	core_src = _get_src(["core"], variant)

	for lib in env:
		# Set common variables
		env[lib]["BOARD"] = board
		env[lib]["BOARD_C_FLAGS"] = cflags
		env[lib]["PATH"] = os.environ["PATH"]

		# Set library specific variables
		if lib == "core":
			lib_src = core_src
			lib_obj = _get_obj(lib_src)
		else:
			# Add the main source folders for the library
			lib_src = _get_src([lib], variant)
			lib_obj = _get_obj(lib_src)
			lib_src.extend(core_src)

			# Include dependency source folders
			if lib in dependencies:
				dep_src = _get_src(dependencies[lib], "n/a")
				lib_src.extend(dep_src)

		env[lib]["SRC_DIRS"] = " ".join(lib_src)
		env[lib]["INCLUDES"] = "-I" + " -I ".join(lib_src)
		env[lib]["LIBOBJS"] = " ".join(lib_obj)

		# Set the compilation directory
		compile_dir = os.path.join(config["compile_root"], "%s/%s" % (board, lib))
		try:
			os.makedirs(compile_dir, mode=0o0775, exist_ok=True)
		except OSError:
			pass
		library_list.append(compile_dir)

		# Find the makefile to use
		makefile = os.path.join(imp_root, "libraries/%s.mk" % lib)
		if not os.path.exists(makefile):
			makefile = os.path.join(imp_root, "Library.mk")

		# Run make in a subprocess
		make_args = ["make", "-f", makefile]
		makes[lib] = subprocess.Popen(make_args, cwd=compile_dir, env=env[lib])

	# Wait for make processes to finish
	error = False
	for lib in makes:
		returncode = makes[lib].wait()
		if returncode != 0:
			error = True

	if error:
		print("Fatal error, unable to compile all libraries.")
		sys.exit(1)

	return library_list


def make(args):
	"""Make the project in the current directory, using its Makefile.

	This function "pre-fills" all imp variables to avoid multiple calls.
	"""
	print("imp make, coming soon.")


class CustomParser(argparse.ArgumentParser):
	"""Argument parser that prints a help message upon erroring."""
	def error(self, message):
		self.print_help()
		print("\nerror: %s" % message)
		sys.exit(1)


def setup_argparser():
	# Top level parser
	parser = CustomParser(prog="imp")
	subparsers = parser.add_subparsers()

	# Help strings
	h_init = "Create a new Arduino project"
	h_init_dir = "The directory in which to create the new project"
	h_list = "List all available boards"
	h_make = "Make the project in the current directory, quickly."
	h_get = "Get compiler flags, compiled libraries, etc"
	h_gprop1= "Get board properties from boards.txt"
	h_gprop2 = "The name of the property as it appears in boards.txt\n" \
		  "E.g. atmega328.build.f_cpu"
	h_board = "The short name of your Arduino board.\n" \
		  "Run `imp list` for a list."
	h_cflags = "Get the compiler flags for a specific board"
	h_src = "Get a list of directories containing library source code."
	h_src_libs = "A list of libraries to get source directories for."
	h_dash_i = "Add a -I before each directory (see gcc's -I option)."

	h_obj = "Get the names of all the .o files for a library."
	h_obj_lib = "The name of the library."

	h_lib = "Get the location(s) of compiled libraries"
	h_lib_libs = "A list of libraries to obtain compiled version of."
	h_dash_l = "Add a -L before each directory (see gcc's -L option)."


	# Parser for `imp init`
	init_parser = subparsers.add_parser("init", help=h_init)
	init_parser.add_argument("dir", nargs="?", default=".", help=h_init_dir)
	init_parser.set_defaults(func=init)

	# Parser for `imp list`
	list_parser = subparsers.add_parser("list", help=h_list)
	list_parser.set_defaults(func=list_boards)

	# Parser for `imp make`
	make_parser = subparsers.add_parser("make", help=h_make)
	make_parser.set_defaults(func=make)

	# Parser for `imp get`
	get_parser = subparsers.add_parser("get", help=h_get)
	get_subparsers = get_parser.add_subparsers()

	# Parser for `imp get property`
	property_parser = get_subparsers.add_parser("property", help=h_gprop1)
	property_parser.add_argument("property", help=h_gprop2)
	property_parser.set_defaults(func=get_property)

	# Parser for `imp get cflags`
	cflags_parser = get_subparsers.add_parser("cflags", help=h_cflags)
	cflags_parser.add_argument("board", help=h_board)
	cflags_parser.set_defaults(func=get_cflags)

	# Parser for `imp get src`
	src_parser = get_subparsers.add_parser("src", help=h_src)
	src_parser.add_argument("libraries", nargs="*", help=h_src_libs)
	src_parser.add_argument("--board", default=None, help=h_board)
	src_parser.add_argument("-I", dest="dash_i", action="store_true", help=h_dash_i)
	src_parser.set_defaults(func=get_src)

	# Parser for `imp get obj`
	obj_parser = get_subparsers.add_parser("obj", help=h_obj)
	obj_parser.add_argument("library", help=h_obj_lib)
	obj_parser.set_defaults(func=get_obj)

	# Parser for `imp get lib`
	lib_parser = get_subparsers.add_parser("lib", help=h_lib)
	lib_parser.add_argument("libraries", nargs="*", help=h_lib_libs)
	lib_parser.add_argument("--board", required=True, help=h_board)
	lib_parser.add_argument("-L", dest="dash_l", action="store_true", help=h_dash_l)
	lib_parser.set_defaults(func=get_lib)

	return parser

def main():
	# Parse args
	parser = setup_argparser()
	args = parser.parse_args()

	# If no command has been given, bail out
	if not hasattr(args, "func"):
		parser.print_help()
		return

	# Read config & execute the command
	global config
	config = read_config()
	args.func(args)


if __name__ == "__main__":
	main()
